# C++编程实战

### 01｜堆、栈、RAII：C++里该如何管理资源？
#### 基本概念
堆(heap)，在内存管理的语境下，指的动态分配内存的区域。这个堆跟数据结构里的堆不是一回事。这里的内存，被分配之后需要手工释放，否则就会造成内存泄漏。

自由存储区，free store，特指使用new和delete来分配和释放内存的区域。一般而言，这是堆堆一个子集：
- new和delete操作的区域是free store
- malloc和free操作的区域是heap
  
栈(stack)，在内存管理的语境下，指的是函数调用过程中产生的本地变量和调用数据的区域。这个栈和数据结构里的栈高度相似，都满足“后进献出”（last-in-first-out或LIFO）

RAII（Resource Acquisition Is Initialization)，是C++所特有的资源管理方式。有少量其他语言，如D、Ada和Rust也采纳了RAII，但主流的编程语言中，C++是唯一一个依赖RAII来做资源管理的。

RAII依托栈和析构函数，来对所有的资源——包括堆内存在内——进行管理。对RAII的使用，使得C++不需要类似于JAVA那样的垃圾收集方法，也能有效的对内存进行管理。RAII的存在，也是垃圾手机虽然理论上可以在C++使用，但从来没有真正流行过的主要原因。


##### 堆
1. 让内存管理分配一个某个大小的内存块
2. 让内存管理器释放一个之前分配的内存块
3. 让内存管理器进行垃圾收集操作，寻找不再使用的内存块并予以释放

第一，分配内存要考虑程序当前已经有多少未分配的内存。
第二，释放内存不只是简单地吧内存标记为未使用。
第三，垃圾收集操作有很多不同的策略和实现方式，以实现性能、实时性、格外开销等各方面的平衡。

##### 栈
新的函数进入后，首先做一些必须的保存工作，然后会调整栈指针，分配出本地变量所需的空间，随后执行函数中的代码,并在执行完毕之后，根据调用者压入栈的地址，返回到调用者未执行的代码中继续执行。

- 栈上分配的极为简单，移动一下栈指针而已。
- 栈上的释放也极为简单，函数执行结束时移动一下栈指针即可。
- 由于后进先出过程，不可能出现内存碎片。

栈帧（stack frame），某个函数占用的栈空间。这部分空间叫栈帧。
编译器会自动调用析构函数，包括在函数执行发生异常的情况。在发生异常时堆析构函数的调用，还有一个专门的术语，叫栈展开(stack unwinding)。

##### RAII
C++支持将对象存储在栈上面。但是，在很懂情况下，对象不能，或不应该，存储在栈上。比如：
- 对象很大；
- 对象的大小在编译器是不能确定；
- 对象时函数的返回值，但由于特殊的原因，不应该使用对象的值返回。

- 在析构函数里做必要的清理工作，这就是RAII的基本用法。
  - 关闭文件(fsteam的析构就会这么做)
  - 释放同步锁
  - 释放其他重要的系统资源
```c++
std::mutex mtx;

void some_func()
{
    std::lock_guard<std::mutex> guard(mtx);
    // 做需要同步的工作
}
```


#### 内容小结
强调栈是C++里最“自然”的内存使用方式，并且，使用基于栈和析构函数的RAII，可以有效的对包括堆内存在内的系统资源进行统一管理。
