# Qt题
### 2、Qt信号和槽点本质是什么？
回调函数。信号或是传递值，或是传递动作变化；槽函数响应信号或是接收值，或者根据动作变化来做出对应操作。

### 4、描述Qt的TCP通信流程


### 11、Qt如果一个信号的处理方法一直未被执行，有哪些可能性？ 
断开了，连接的时候失败了，多线程的时候再排队或者启动了锁死。
### 12、在Qt5的信号处理中，如何使用lambda机制？
信号定义了，但是不写对应的槽函数，直接将函数写到槽的位置。
```C++
connect(musicPlayer,SIGNAL(positionChanged(qint64)),this,SLOT(slotReflushStartTime(qint64)));
connect(musicPlayer,SIGNAL(positionChanged(qint64)),SLOT(slotReflushStartTime(qint64)));
```
### 13、段错误一般是什么原因造成的，如何快速排查？
一般是指针的问题，出现野指针空指针；用点灯或者Debug去排查问题。
### 14、Qt三大核心机制：信号槽、元对象系统、事件模型
#### 信号槽
信号槽有五种连接方式；(参考第17题)
connect(信号发出者，信号，信号接收者，槽，连接方式(隐藏默认自动连接));

#### 元对象系统
元对象系统分为三大类：QObject类、Q_OBJECT宏和元对象编译器moc;
Qt的类包含Q_OBJECT宏，moc编译器会对该类编译成标准的C++代码。

#### 事件模型
##### 事件的创建
鼠标事件、键盘事件、窗口调整事件、模拟事件

##### 事件的交付
Qt通过调用虚函数QObject::event()来交付事件。

##### 事件循环模型
主事件循环通过调用QCoreApplicat::exec()启动，随着QCoreApplication::exit()结束，本地的事件循环可利用QEventLoop构建。
一般来说，事件是由出发当前的窗口系统产生的，但也可以通过使用QCoreApplication::sendEvent()和QCoreApplication::postEvent()来手工产生事件。需要说明的是QCoreApplication::sendEvent()会立即发送事件，QCoreApplication::postEvent()则会将事件放在事件队列分发。

#### 自定义事件

### 15、Qt对象树
QT提供了对象树机制，能够自动、有效的组织和管理继承自QObject的对象。
每个继承自QObject类的对象通过链表(QObjectList)来管理子类对象，当用户创建一个字对象时，其对象链表相应更新子类对象的信息，对象链表可通过children()获取。
当每个父类对象析构的时候，其对象链表中的所有(子类)对象也会被析构，父对象会自动，将其从父对象列表中删除，QT保证没有对象会被delete两次。开发中手动回收资源时建议使用deleteLater代替delete，因为deleteLater多次时安全的。

### 16、描述QTextSTream(文件流)和QDataStram(数据流)的区别
文本流用来操作轻量级的数据，比如内置的int、QString等，写入文件以后文本的方式呈现数据流，可以操作各种类型数据，总之，两者都可以进行操作磁盘文件以及内存数据。

### 17、信号槽的四种写法和五种连接方式？
connect(信号发出者,信号,信号接收者,槽,连接方式(隐藏默认自动连接)) // 五个参数
四种写法：
1. 用宏：
   ```C++
   connect(this,SIGNAL(clicked()),this,SLOT(close()));  // 连接方式(隐藏默认自动连接)
   ```
2. 用函数指针
   ```C++
   connect(this,&mainwindow::my_signal,this,&mainwindow::my_slot);
   ```
3. 用重载函数指针QOverload
   ```C++
   connect(this,Qoverload<参数>::of(&mainwindow::my_signal),this,Qoverload<参数>::of(&mainwindow::my_slot));
   ```
4. lambda表达式(匿名函数)匿名函数代替槽
   ```C++
   connect(this,&mainwindow::my_signal,this,[=]{qDebug()<<100;});
   ```

连接方式：
- 自动连接(默认连接方式)
- 直接连接(用于单线程，自动匹配)
- 队列（用于多线程也可以用于单线程，自动匹配)
- 阻塞队列(跨线程，多线程)
- 唯一连接(跨线程，多线程)

### 18、Qt模型
Qt的View主要有三种QListView, QTreeView, QTabelView
而对应的Model是：QStringListModel, QAbstractltemModel, QStandarItemModel.
抽象、标准

### 19、Qt中的MVD了解吧？
Qt的MVD包含三个部分Model(模型)，View(视图)，代理(Delegate)。Model否则保存数据，View负责展示数据，Delegate负责Item样式绘制或处理输入。这三部分通过信号来进行通信，当Model中数据发生变化时，将会发送信号到View，在View中编辑数据时，Delegate负责将编辑状态发送给Model层。基类分别为QAbstracItemModel、QAbstractItemView、QAbstractItemDelegate。Qt中提供了默认实现的MVD类，如QTableWidget、QListWidget、QTreeWidget等。

### 20、Qt如果要进行网络编程首先需要在.pro中添加如下代码QT network
1. 在头文件中包含相关头文件：
```C++
#include <QHostInfo>
#include <QNetworkInterface>
```
2. QT的UdpSocket接收消息使用原则
- 第一步：new一个UdpSocket
- 第二步：调用UdpSocket的bind方法，同时指定端口号
- 第三步：使用connect将接收消息函数和UdpSocket对象做关联
- 第四步：在接收消息槽函数当中调用readDatagram接收消息

### 21、static和const的使用
**static**：
`静态变量声明，分为局部静态变量，全局静态变量 ，类静态成员变量。也可修饰类成员函数。有以下几类：`
- 局部静态变量：存储在静态存储区 ，程序运行期间只被初始化一次，作用域仍然为局部作用域，在变量定义的函数或语句块中有效，程序结束时由操作系统回收资源。
- 全局静态变量：存储在静态存储区，静态存储区中的资源在程序运行期间会一直存在，直到程序结束由系统回收。未初始化的变量会默认为0，作用域在声明他的文件中有效。
- 类静态成员变量：被类的所有对象共享，包括子对象。必须在类外初始化，不可以在构造函数内进行初始化。
- 类静态成员西数：所有对象共享该函数，不含this指针，不可使用类中非静态成员。

**const**：
`常量声明，类常成员函数声明。`
const和static不可同时修饰类成员函数，const修饰成员函数表示不能修改对象的状态，static修饰成员函数表示该函数属于类，不属于对象，二者相互矛盾。const修饰变量时表示变量不可修改 ，修饰成员西数表示不可修改任意成员变量。

### 23、指针和引用的异同
**指针**：是一个变量，但是这个变量存储的是另一个变量的地址，我们可以通过访问这个地址来修改变量。
**引用**：是一个别名，还是变量本身。对引用进行的任何操作就是对变量本身进行的操作。
**相同点**：二者都可以对变量进行修改。
**不同点**：
- 指针可以不必须初始化，引用必须初始化。
- 指针可以有多级，但是引用只有一级（int&&a不合法，int**p合法）。
- 指针在初始化后可以改变，引用不能进行改变，即无法再对另一个同类型对象进行引用。
- sizeo指针可以得到指针本身大小，sizeof引用得到的是变量本身大小。
- 指针传参还是值传递，引用传参传的是变量本身。

### 24、常用数据结构
- vector ：向量，连续存储，可随机访问。
- deque：双向队列，连续存储，随机访问。
- list ：链表，内存不连续，不支持随机访问。
- stack ：栈，不可随机访问，只允许再开头增加/删除元素。
- queue：单向队列，尾部增加，开头删除。
- set：集合 ，采用红黑树实现，可随机访问。查找、插入、删除时间复杂度为O(logn)。
- map：图，采用红黑树实现，可随机访问。查找、插入、删除时间复杂度为O(logn)。
- hash_set ：哈希表，随机访问。查找、插入、删除时间复杂读为O(1)。

### 25、谈谈你对面向对象的理解
**C++面向对象编程**就是把一切事物都变成一个个对象，用属性和方法 来描述对象的信息，比如定义一个猫对象，猫的眼睛、毛发、嘴巴就可以定义为猫对象的属性，猫的叫声和走路就可以定义为猫对象的方法。

用对象的方式编程，不仅方便了程序员，也使得代码的可复用性、可维护性变好。

C++面向对象的**三大特性**是`封装、继承、多态`。

### 26、什么场景下使用继承方式 ，什么场景下使用组合？
**继承**：通过扩展已有的类来获得新功能的代码重用方法
**组合**：新类由现有类的对象合并而成的类的构造方式
使用场景：
1. 如果二者存在一个"是"的关系，并且一个类要对另外一个类公开所有接口，那么继承是更好的选择
2. 如果二者间存在一个'有"的关系，那么首选组合
3. 如果没有找到及其强烈无法辩驳的使用继承的的理由的时候，一律使用组合。组合体现为现实层面，继承主要体现在扩展方面。如果并不需要一个类的所有东西（包括接口和熟悉），那么就不需要使用继承，使用组合更好。如果使用继承，那么必须所有的都继承，如果有的东西你不需要继承但是你继承了，那么这就是滥用继承。

### 27、如何理解多态？
定义：同一操作作用于不同的对象，产生不同的执行结果。C++多态意味着当调用虛成员函数时，会根据调用类型对象的实际类型执行不同的操作。
实现：通过虚函数实现，用virtual声明的成员函数就是虚函数，允许子类重写。声明基类的指针或者引用指向不同的子类对象，调用相应的虚函数，可以根据指针或引用指向的子类的不同从而执行不同的操作。
Overload（重载）：函数名相同 ，参数类型或顺序不同的函数构成重载。
override（重写）：派生类覆盖基类用virtual声明的成员函数。
overwrite（隐藏）：派生类的函数屏蔽了与其同名的基类函数。派生类的函数与基类函数同名，但是参数不同，隐藏基类函数。如果参数相同，但是基类没有virtual关键字 ，基类函数将被隐藏。

### 28、虚函数表
`多态是由虚函数实现的`，而虚函数主要是通过`虚函数表`实现的。如果一个类中包含虚函数，那么这个类就会包含一张虛函数表，`虚函数表存储的每一项,是一个虚函数的地址`。该类的每个对象都会包含一个虚指针（虛指针存在于对象实例地址的最前面，保证虚函数表有最高的性能），需指针指向虛函数表。
注意：对象不包含虚函数表，只有需指针，类才包含虚函数表，派生类会生成一个兼容基类的虚函数表。


## 设计模式面试题
### 29、分别写出饿汉和懒汉线程安全的单例模式
单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。根据单例对象创建时间，可分为两种模式：懒汉模式和饿汉模式。
- 懒汉模式：延迟加载，不到万不得已不会去实例化类，也就是说第一次用到类实例的时候才会实例化。
- 饿汉模式 ：在单例类定义的时候（即在main函数之前）就进行实例化。因为main函数执行之前，全局作用域的类成员变量instance_已经初始化，故没有多线程的问题。

### 30、说出观察者模式类关系和优点

### 31、说出代理模式类关系和优点
优点：代理模式能将代理对象与真实被调用的目标对象隔离。
一定程度上降低了系统的轉合度，扩展性好。
可以起到保护目标对象的作用。
可以对目标对象的功能增强。
缺点：
代理模式会造成系统设计中类的数量增加。
在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢。

### 32、说出工厂模式概念和优点

### 33、说出构造者模式概念

### 34、说出适配器模式概念

### 35、进程和线程的区别？
进程的定义：一个具有一定独立功能的程序，在一个数据集合上依次动态执行的过程。进程是一个正在执行程序的实例，包括程序计数器、奇存器和程序变量的当前值。简单来说，进程就是一个程序的执行流程，内部保存程序运行所需的资源。在操作系统中可以有多个进程在运行，可对于CPU来说，同一时刻，一个CPU只能运行一个进程，但在某一时间段内，CPU将这一时间段拆分成更短的时间片，CPU不停的在各个进程问游走，这就给人一种并行的错觉，像CPU可以同时运行多个进程一样，这就是伪并行。

线程的定义 ：线程是进程当中的一条执行流程 ，这几乎就是进程的定义，一个进程内可以有多个子执行流程，即线程。从资源组合的角度看 ，进程把一组相关的资源组合起来，构成一个资源平台环境，包括地址空间（代码段，数据段），打开的文件等各种资源。从运行的角度看：进程是代码在这个资源平台上的执行流程，然而线程貌似也是这样，但是进程比线程多了资源内容列表样式：进程 = 线程＋共享资源。
进程是操作系统分配资源的单位，线程是调度的基本单位，线程之间共享进程资源。

### 36、进程之间的通信方式有哪些？
1. 管道
2. 消息队列
3. 共享内存
4. 信号量
5. 套接字
6. 文件

### 37、信号和信号量的区别是什么？
信号：一种处理异步事件的方式。信号是比较复杂的通信方式，用于通知接收进程有某种事件发生，除了用于进程外，还可以发送信号给进程本身。
信号量：进程间通信处理同步互斥的机制。是在多线程环境下使用的一种设施，它负责协调各个线程，以保证它们能够正确，合理的使用公共资源。

### 38、你觉得自定义控件的方法主要是哪些？
- 从外观设计上：QSS、继承绘制函数重绘、继承QStyle相关类重绘、组合拼接等等。
- 从功能行为上：重写事件函数、添加或者修改信号和槽等等。

### 39、QSS平时使用的多吗？能举几个例子吗？
1. 将Qss统一写在一个文件中，通过程序给主窗口加载；
2. 写成一个字符串中，通过程序给主窗口加载；
3. 需要使用的地方，写一个字符串，加载给对象；
4. QT Designer中填写；

### 40、Qt程序是事件驱动的，事件到处都可以遇到。能说说平时经常使用到哪些事件吗？
常见的QT事件类型如下：
- 键盘事件：按键按下和松开 
- 鼠标事件：鼠标移动,鼠标按键的按下和松开
- 拖放事件：用鼠标进行拖放 
- 滚轮事件：鼠标滚轮滚动
- 绘屏事件：重绘屏幕的某些部分 
- 定时事件：定时器到时
- 焦点事件：键盘焦点移动 
- 进入和离开事件：鼠标移入widget之内,或是移出
- 移动事件：widget的位置改变 
- 大小改变事件：widget的大小改变
- 显示和隐藏事件：widget显示和隐藏
- 窗口是否为当前窗口

### 41、 多线程情况下，Qt中的信号槽分别在什么线程中执行，如何控制？
通过connect函数的第五个参数connectType来控制。
connect用于连接qt的信号和槽，在qt编程过程中不可或缺。它其实有第五个参数，只是一般使用默认值，在满足某些特殊需求的时候可能需要手动设置。

- **Qt:Autoconnection** 默认值，使用这个值则连接类型会在信号发送时決定。如果接收者和发送者在同一个线程，则自动使用Qt::DirectConnection类型。如果接收者和发送者不在一个线程，则自动使用Qt:QueuedConnection类型。
- **Qt::DirectConnection** 槽函数会在信号发送的时候直接被调用，槽函数运行于信号发送者所在线程。效果看上去就像是直接在信号发送位置调用了槽函数。这个在多线程环境下比较危险，可能会造成奔溃。
- **Qt::QueuedConnection**：槽函数在控制回到接收者所在线程的事件循环时被调用，槽函数运行于信号接收者所在线程。发送信号之后，槽函数不会立刻被调用 ，等到接收者的当前函数执行完，进入事件循环之后，槽函数才会被调用。多线程环境下一般用这个。
- **Qt:BlockingQueuedConnection**：槽函数的调用时机与Qt:QueuedConnection一致，不过发送完信号后发送者所在线程会阻塞，直到槽函数运行完。接收者和发送者绝对不能在一个线程 ，否则程序会死锁。在多线程间需要同步的场合可能需要这个。
- **Qt:Uniqueconnection**：这个flag可以通过按位或（｜）与以上四个结合在一起使用。当这个flag设置时，当某个信号和槽已经连接时 ，再进行重复的连接就会失败。也就是避免了重复连接。

### 42、继承和派生的区别？
1. 角度不同
继承是从子类的角度讲的，派生是从基类的角度讲的。
2. 定义不同
派生指江河的源头产生出支流。引申为从一个主要事物的发展中分化出来。**继承** 是面向对象软件技术当中的一个概念，与多态、抽象共为面向对象的三个基本特征。继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等.

### 43、单继承和多继承
单继承(派生类只从一个直接基类继承)时派生类的定义：
class 派生类名：继承方式 基类名
{
   新增成员声明;
}

多继承时派生类的定义：
class 派生类名：继承方式1 基类名1，继承方式2 基类名2,...
{
   成员声明;
}
**注意：** 每一个“继承方式"，只用于限制对紧随其后之基类的继承。

### 47、知道死锁妈？死锁死如何产生的？
死锁的产生有如下四个必要条件：
1. 资源时互斥的，同一时刻只能有一个进程占有该资源
2. 资源的释放只能有该进程自己完成
3. 线程在获取到需要资源之前，不回释放已有资源。
4. 存在这么一条循环等待的队列，线程 T1,T2,T3...,Tn
T1持有自己的资源请求T2的资源，...Tn持有自己的资源请求T1点资源

### 48、Qt线程同步的方法有哪些？
1. 互斥量(QMutex)
```C++
QMutex m_Mutex;
m_Mutex.lock();
m_Mutex.unlock();
```
2. 互斥锁(QMutexLocker)
```C++
QMutexLocker mutexLocker(&m_Mutex);
// 从声明出开始(在构造函数中加锁)，出了作用域自动解锁(在析构函数中解锁)。
```
3. 等待条件(QWaitCondition)
```C++
QWaitCondtion m_WaitCondtion;
m_WaitCondtion.wait(&m_mutex, time);
m_WaitCondtion.wakeAll();
```
4. QReadWriteLock类
一个线程试图对一个加了读锁的互斥量进行上读锁，允许；
》一个线程试图对一个加了读锁的互斥量进行上写锁，阳寨；
》一个线程试图对一个加了写锁的互斥量进行上读锁，阻塞；
》一个线程试图对一个加了写锁的互斥量进行上写锁，阻塞。
读写锁比较适用的情况是：需要多次对共享的数据进行读操作的阅读线程。
QReadWriterLock 与QMutex相似，除了它对"read""write"访问进行区别对待。它使得多个读者可以
共时访问数据。使用QReadWriteLock而不是QMutex，可以使得多线程程序更具有并发性。
5. 信号量QSemaphore
但是还有些互斥量（资源）的数量并不止一个，比如一个电脑安装了2个打印机，我已经申请了一个，但
是我不能霸占这两个，你来访问的时候如果发现还有空闲的仍然可以申请到的。于是这个互斥量可以分
为两部分 ，已使用和未使用。
6.0ReadLocker便利类和QWrite Locker便利类对QReadWriteLock进行加解锁

### 67、对C++11的智能指针了解多少？可以自己实现一个智能指针吗？
三种智能指针：
- std::shared_ptr：使用引用技术，每一个shared_ptr的拷贝都指向相同的内存，每次拷贝都会触发引用计数+1，每次声明周期结束析构的时候引用计数-1，在最后一个shared_ptr析构的时候，内存才会释放。
- std::weak_ptr：用来见识shared_ptr的生命周期，它不管里shared_ptr内部的指针，它拷贝析构都不会影响引用计数，纯粹是作为一个旁观者监视shared_ptr中管理的资源是否存在，可以用来`返回this指针和解决循环引用问题`。
- std::unique_ptr：独占型的智能指针，它不允许其他智能指针共享其内部指针，也不允许unique_ptr的拷贝和赋值。

### 71、Qt的D指针(d_ptr)与Q指针(q_ptr)
D指针：PIMPL模式，指向一个包含所有数据的私有数据结构体。
- 私有的结构体可以随意改变，而不需要重新编译整个工程项目
- 隐藏实现细节
- 头文件中没有任何实现细节，可以作为API使用
- 原本在头文件的实现部分转移到源文件，所以编译速度有所提高

Q指针：私有的结构体中储存一个指向共有类的Q指针
总结：
- Qt中的一个类常用一个Privatexxx类来处理内部逻辑，使得内部逻辑与外部接口分开，这个Privatexxx对象通过D指针来访问；在Privatexxx中有需要引1用Owner的内容，通过Q指针来访问。
- 由于D和Q指针是从基类继承下来的，子类中由于继承导致类型发生变化，需要通过 `static_cast`类型转化，所以`DPTRO()`与 `QPTR()` 宏定义实现了转换。

### 73、Qt connect的第五个参数(信号槽连接方式)？

### 83、面向对象三大特性以及C++成员函数
面向对象的三大特性：封装、继承、多态
类的六个默认成员函数：
- 构造函数
- 拷贝构造函数
- 析构函数
- 赋值操作符重载
- const修饰的取地址操作符重载

### 84、使用样式表要注意的点

### 86、QApplication的主要作用是什么？
QApplication对象管理QtGui应用程序的控制流和主要的设置参数

### 96、C++内存分配有几种方式？
内存的三种分配方式：
1. 从静态存储区分配：
2. 在栈区分配：
3. 在堆区分配：动态分配内存。用new/malloc时开辟，delete/free时释放。生存气由用户指定，灵活。但有内存泄漏等问题。

### 98、Qt Socket通信过程
Qt Socket通信等过程主要分为以下几步：
1. 创建Socket：使用QTcpSocket类创建Socket，并初始化连接参数
2. 连接服务器：使用connectToHost()函数连接服务器；
3. 发送数据：使用write()函数发送数据；
4. 断开连接：使用disconnectFromHost()函数断开连接。
   
### 100、用Qt实现一个三角形的按钮，会如何实现？
首先，我们需要使用Qt的QPushButton类来创建一个按钮，然后设置按钮的样式，使其可以显示出一个三角形的形状。
1. 创建QPushButton类的实例，并设置按钮的样式：
```C++
QPushButton *triangleButton = new QPushButton();
triangleButton->setStyleSheet("")
```
2. 设置按钮大小
3. 连接按钮点击信号和槽函数
4. 实现槽函数

### 103、Qt的智能指针，QSharePoint和shared_ptr有什么区别，weak_ptr呢？
Qt智能指针式一种特殊的指针，它可以指向另一个指针。它可以用来创建复杂的数据结构，如链表或树结构。
QSharePoint是一种智能指针，它可以自动管理指向对象的内存分配和释放，从而实现自动内存管理。
shared_ptr也是一种智能指针，它可以跟踪指向的对象的引用技术，从而保证在没有任何引用的情况下，可以自动释放指向的对象。
weak_ptr是一种特殊的shared_ptr，它可以指向shared_ptr指向的对象，但不会增加对象的引用计数。它可以用来避免循环引用导致的内存泄漏问题。
在Qt中，指针式一种指向指针的指针，通常用于动态分配内存或者多级指针操作。而QSharedPointer和std::shared_ptr都是C++11中的智能指针。用于管理动态内存，可以避免内存泄漏和悬空指针等问题。它们主要区别如下：


### 106、死锁怎么解决？
1. 避免死锁：


### 109、常用的Qt布局有几种，如何自适应缩放？
Qt布局有以下几种：
1. 绝对布局
2. 盒子布局
3. 栅格布局
4. 流式布局
5. 堆栈布局

### 117、描述过程，如何实现一个自定义按钮，使其在光标进入，按下，离开三种状态下显示不同的图片？
1. 在项目中创建三张图片，分别表示光标进入，按下，离开三种状态下的图片。
2. 创建一个自定义按钮类，在该类中重写onMouseEnter，onMouseDown，onMouseLeave三个事件，分别设置按钮的图片为对应的三种图片。
3. 在需要使用自定义按钮的地方，实例化自定义按钮类，并将其添加到页面中，即可实现光标进入，按下，离开三种状态下显示不同的图片。

### 118、什么是Qt事件循环？
Qt事件循环是一种程序框架，它用于处理窗口系统和其他用户界面事件，以及与用户界面无关的事件，例如定时器和网络事件。Qt事件循环以循环方式运行，每次循环都会检查是否有新的事件，如果有，就会调用相应的处理程序来处理它们。

### 119、Qt打包程序
1. 安装pyinstaller：使用pip安装pyinstaller，在命令行输入pip install pyinstaller即可。
2. 生存可执行文件：在命令行输入pyinstaller -F -w, 其中filename为打宝的文件名。
3. 打包：将生成的可执行文件和其他需要的文件(如图片、音频等)放到一个文件夹中，然后使用pyinstaller -F -w 命令打包。
4. 安装：将生成的可执行文件安装到目标系统中即可。

### 120、纯虚函数和普通的函数有什么区别？
1. 纯虚函数是抽象类中的虚函数，它只有声明没有实现，它的实现由派生类完成，纯虚函数必须在派生类中实现。
2. 普通虚函数是普通类中的虚函数，它由声明也有实现，派生类可以重定义它，也可以不重定义它。

### 121、虚继承的作用？
虚继承的作用是避免了多重继承时出现的二义性问题，即消除了基类的二义性，使得子类中只有一个完整的基类对象，从而避免了多重继承时出现的二义性问题。

### 126、

### 127、Qt中的容器类包括
QList：动态数组，支持随机访问和快速插入、删除操作。
QVector：类似QList，但具有更好的性能。
QLinkedList：双向链表，支持快速插入、删除操作。
QHash：哈希表，支持快速查找、插入、删除操作。
QMap：基于红黑树的映射表，支持快速查找、插入、删除操作。

### 136、多态实现的原理？链表和数组有何区别？队列和栈区别？
实现多态的关键时虚函数和指针。在C++中，通过将基类中的某个函数声明为虚函数，可以使得派生类中的同名函数称为虚函数，从而实现多态。当通过积累指针或引用某个虚函数时，会根据指针引用实际指向的对象类型来调用相应的函数，实现了动态绑定。这样就可以在不同的对象之间实现相同的操作，提高了代码的复用性和可维护性。

### Qt编程当中，多线程的两种使用方法？
在Qt编程中，多线程的两种使用方法分别是：
1. 继承QThread类：是一种常见的多线程编程方法。该方法需要定义一个新类，继承自QThread类，并重写run()函数，run()函数中包含了需要在新线程中执行的代码。在主线程中创建该类的实例对象，调用start()函数启动了新的线程。

